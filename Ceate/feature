---@Component
public class S3UploadDispatcher {

    private final ExecutorService uploaderPool;
    private final S3Client s3Client;
    private final String bucketName = "your-bucket-name";

    public S3UploadDispatcher() {
        this.s3Client = S3Client.builder()
                .region(Region.of("your-region"))
                .build();

        this.uploaderPool = new ThreadPoolExecutor(
                10, 20,
                60, TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(1000),
                new ThreadPoolExecutor.CallerRunsPolicy() // fallback to avoid blocking
        );
    }

    public void uploadFile(String baseFileName, String content) {
        uploaderPool.submit(() -> {
            try {
                String dateFolder = LocalDate.now().toString();
                String uniqueFileName = baseFileName + "_" + System.currentTimeMillis() + ".txt";
                String key = dateFolder + "/" + uniqueFileName;

                s3Client.putObject(
                        PutObjectRequest.builder()
                                .bucket(bucketName)
                                .key(key)
                                .contentType("text/plain")
                                .build(),
                        RequestBody.fromBytes(content.getBytes())
                );
            } catch (Exception e) {
                e.printStackTrace(); // log properly in production
            }
        });
    }
}


@Component
public class FileWriteDispatcher {

    private static final String BASE_DIR = "/your/output/path";
    private final ExecutorService writerPool;

    public FileWriteDispatcher() {
        // Tune pool size and queue capacity as needed
        this.writerPool = new ThreadPoolExecutor(
                10,                      // core threads
                20,                      // max threads
                60, TimeUnit.SECONDS,   // idle timeout
                new LinkedBlockingQueue<>(1000), // request queue
                new ThreadPoolExecutor.CallerRunsPolicy() // fallback if queue is full
        );
    }

    public void dispatchWrite(String filename, String content) {
        writerPool.submit(() -> {
            try {
                String dateFolder = LocalDate.now().toString(); // e.g. 2025-05-07
                Path folderPath = Paths.get(BASE_DIR, dateFolder);
                Files.createDirectories(folderPath);

                // Create unique file per request using timestamp or UUID
                String uniqueFileName = filename + "_" + System.currentTimeMillis() + ".txt";
                Path filePath = folderPath.resolve(uniqueFileName);

                Files.write(filePath, content.getBytes(), StandardOpenOption.CREATE_NEW);
            } catch (IOException e) {
                e.printStackTrace(); // Replace with proper logging
            }
        });
    }
}

-----------------------
@Component
public class FileWriteDispatcher {

    private final ExecutorService writerPool;
    private final String BASE_DIR = "/your/output/path";

    public FileWriteDispatcher() {
        this.writerPool = Executors.newFixedThreadPool(10); // Tune pool size as needed
    }

    public void dispatchWrite(String filename, String content) {
        writerPool.submit(() -> {
            try {
                String dateFolder = LocalDate.now().toString();
                Path folderPath = Paths.get(BASE_DIR, dateFolder);
                Files.createDirectories(folderPath);

                Path filePath = folderPath.resolve(filename + ".txt");

                Files.write(filePath, content.getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
            } catch (IOException e) {
                e.printStackTrace(); // Or log error
            }
        });
    }
}

-----------

@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean("fileWriterExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);       // Tune as per your load
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("FileWriter-");
        executor.initialize();
        return executor;
    }
}

@Service
public class FileWriterService {

    private static final String BASE_DIR = "/your/base/output/path";

    @Async("fileWriterExecutor")
    public void writeToFile(String filename, String content) {
        try {
            String dateFolder = LocalDate.now().toString(); // e.g., 2025-05-07
            Path folderPath = Paths.get(BASE_DIR, dateFolder);
            Files.createDirectories(folderPath);

            Path filePath = folderPath.resolve(filename + ".txt");

            Files.write(filePath, content.getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        } catch (IOException e) {
            // You may log or handle exceptions based on your requirement
            e.printStackTrace();
        }
    }
}

