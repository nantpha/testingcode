import software.amazon.awssdk.core.async.AsyncResponseTransformer;
import software.amazon.awssdk.services.s3.model.GetObjectResponse;
import software.amazon.awssdk.core.ResponseBytes;
import org.mockito.ArgumentMatchers;

private void mockGetObject(String key, String content) {
    when(s3AsyncClient.getObject(
        argThat(req -> req.bucket().equals("bucket") && req.key().equals(key)),
        // Explicitly specify the generic type parameters
        ArgumentMatchers.<AsyncResponseTransformer<GetObjectResponse, ResponseBytes<GetObjectResponse>>>any()
    )).thenReturn(CompletableFuture.completedFuture(
        ResponseBytes.fromByteArray(
            GetObjectResponse.builder().build(), 
            content.getBytes()
        )
    ));
}



@Test
void testBasicPairDownload() throws IOException {
    // Mock S3 listObjectsV2 response with one page of files
    when(s3AsyncClient.listObjectsV2(any(ListObjectsV2Request.class)))
        .thenReturn(CompletableFuture.completedFuture(
            ListObjectsV2Response.builder()
                .contents(
                    S3Object.builder().key("prefix/file1.json").build(),
                    S3Object.builder().key("prefix/file1.xml").build(),
                    S3Object.builder().key("prefix/file2.json").build(),
                    S3Object.builder().key("prefix/file2.xml").build()
                )
                .build()
        ));

    // Mock getObject responses
    mockGetObject("prefix/file1.json", "json1");
    mockGetObject("prefix/file1.xml", "xml1");
    mockGetObject("prefix/file2.json", "json2");
    mockGetObject("prefix/file2.xml", "xml2");

    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    s3ZipService.streamFilesToZip("bucket", "prefix/", 0, 2, outputStream);

    // Verify ZIP contains all four files with correct content
    Map<String, String> zipEntries = readZipEntries(outputStream.toByteArray());
    assertEquals(4, zipEntries.size());
    assertEquals("json1", zipEntries.get("file1.json"));
    assertEquals("xml1", zipEntries.get("file1.xml"));
    assertEquals("json2", zipEntries.get("file2.json"));
    assertEquals("xml2", zipEntries.get("file2.xml"));
}




private Map<String, String> readZipEntries(byte[] zipBytes) throws IOException {
    Map<String, String> entries = new HashMap<>();
    try (ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(zipBytes))) {
        ZipEntry entry;
        while ((entry = zis.getNextEntry()) != null) {
            String content = new String(zis.readAllBytes());
            entries.put(entry.getName(), content);
            zis.closeEntry();
        }
    }
    return entries;
}

private void mockGetObject(String key, String content) {
    when(s3AsyncClient.getObject(
        argThat(req -> req.bucket().equals("bucket") && req.key().equals(key)),
        any(AsyncResponseTransformer.class))
    ).thenReturn(CompletableFuture.completedFuture(
        ResponseBytes.fromByteArray(GetObjectResponse.builder().build(), content.getBytes())
    ));
}

@Test
void testPaginationHandling() throws IOException {
    // First page response
    when(s3AsyncClient.listObjectsV2(argThat(req -> req.continuationToken() == null)))
        .thenReturn(CompletableFuture.completedFuture(
            ListObjectsV2Response.builder()
                .contents(S3Object.builder().key("prefix/file1.json").build())
                .nextContinuationToken("token1")
                .build()
        ));

    // Second page response
    when(s3AsyncClient.listObjectsV2(argThat(req -> "token1".equals(req.continuationToken()))))
        .thenReturn(CompletableFuture.completedFuture(
            ListObjectsV2Response.builder()
                .contents(S3Object.builder().key("prefix/file1.xml").build())
                .build()
        ));

    mockGetObject("prefix/file1.json", "json1");
    mockGetObject("prefix/file1.xml", "xml1");

    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    s3ZipService.streamFilesToZip("bucket", "prefix/", 0, 1, outputStream);

    Map<String, String> zipEntries = readZipEntries(outputStream.toByteArray());
    assertEquals(2, zipEntries.size());
    assertTrue(zipEntries.containsKey("file1.json"));
    assertTrue(zipEntries.containsKey("file1.xml"));
}





import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import software.amazon.awssdk.services.s3.S3AsyncClient;
import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;
import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;
import software.amazon.awssdk.services.s3.model.S3Object;
import software.amazon.awssdk.services.s3.paginators.ListObjectsV2Publisher;
import org.reactivestreams.Subscriber;

import java.util.Arrays;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class S3ServiceTest {

    @Mock
    private S3AsyncClient s3AsyncClient;

    @Mock
    private ListObjectsV2Publisher listObjectsV2Publisher;

    private S3Service s3Service;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        s3Service = new S3Service(s3AsyncClient);
    }

    @Test
    void testCountFilesInBucket_Success() throws ExecutionException, InterruptedException {
        // Arrange
        String bucketName = "test-bucket";
        ListObjectsV2Response response1 = ListObjectsV2Response.builder()
                .contents(
                        S3Object.builder().key("file1.txt").build(),
                        S3Object.builder().key("file2.txt").build()
                )
                .isTruncated(false) // No more pages
                .build();

        when(s3AsyncClient.listObjectsV2Paginator(any(ListObjectsV2Request.class)))
                .thenReturn(listObjectsV2Publisher);

        doAnswer(invocation -> {
            Subscriber<? super ListObjectsV2Response> subscriber = invocation.getArgument(0);
            subscriber.onSubscribe(mock(Subscription.class));
            subscriber.onNext(response1);
            subscriber.onComplete();
            return null;
        }).when(listObjectsV2Publisher).subscribe(any());

        // Act
        CompletableFuture<Integer> result = s3Service.countFilesInBucket(bucketName);
        int fileCount = result.get();

        // Assert
        assertEquals(2, fileCount);
        verify(s3AsyncClient, times(1)).listObjectsV2Paginator(any(ListObjectsV2Request.class));
    }

    @Test
    void testCountFilesInBucket_Pagination() throws ExecutionException, InterruptedException {
        // Arrange
        String bucketName = "test-bucket";
        ListObjectsV2Response response1 = ListObjectsV2Response.builder()
                .contents(
                        S3Object.builder().key("file1.txt").build(),
                        S3Object.builder().key("file2.txt").build()
                )
                .isTruncated(true) // More pages to fetch
                .nextContinuationToken("next-token")
                .build();

        ListObjectsV2Response response2 = ListObjectsV2Response.builder()
                .contents(
                        S3Object.builder().key("file3.txt").build()
                )
                .isTruncated(false) // No more pages
                .build();

        when(s3AsyncClient.listObjectsV2Paginator(any(ListObjectsV2Request.class)))
                .thenReturn(listObjectsV2Publisher);

        doAnswer(invocation -> {
            Subscriber<? super ListObjectsV2Response> subscriber = invocation.getArgument(0);
            subscriber.onSubscribe(mock(Subscription.class));
            subscriber.onNext(response1);
            subscriber.onNext(response2);
            subscriber.onComplete();
            return null;
        }).when(listObjectsV2Publisher).subscribe(any());

        // Act
        CompletableFuture<Integer> result = s3Service.countFilesInBucket(bucketName);
        int fileCount = result.get();

        // Assert
        assertEquals(3, fileCount);
        verify(s3AsyncClient, times(1)).listObjectsV2Paginator(any(ListObjectsV2Request.class));
    }

    @Test
    void testCountFilesInBucket_Error() {
        // Arrange
        String bucketName = "test-bucket";
        when(s3AsyncClient.listObjectsV2Paginator(any(ListObjectsV2Request.class)))
                .thenReturn(listObjectsV2Publisher);

        doAnswer(invocation -> {
            Subscriber<? super ListObjectsV2Response> subscriber = invocation.getArgument(0);
            subscriber.onSubscribe(mock(Subscription.class));
            subscriber.onError(new RuntimeException("S3 error"));
            return null;
        }).when(listObjectsV2Publisher).subscribe(any());

        // Act & Assert
        CompletableFuture<Integer> result = s3Service.countFilesInBucket(bucketName);
        ExecutionException exception = assertThrows(ExecutionException.class, result::get);
        assertEquals("S3 error", exception.getCause().getMessage());
    }

    @Test
    void testCountFilesInBucket_InvalidBucketName() {
        // Arrange
        String bucketName = "";

        // Act & Assert
        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> s3Service.countFilesInBucket(bucketName)
        );
        assertEquals("Bucket name cannot be null or empty", exception.getMessage());
    }
}

---------------------------

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import software.amazon.awssdk.core.async.AsyncResponseTransformer;
import software.amazon.awssdk.core.SdkBytes;
import software.amazon.awssdk.services.s3.S3AsyncClient;
import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;
import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;
import software.amazon.awssdk.services.s3.model.S3Object;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CompletableFuture;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class S3ServiceTest {

    @Mock
    private S3AsyncClient s3AsyncClient;

    @InjectMocks
    private S3Service s3Service;

    private ByteArrayOutputStream outputStream;

    @BeforeEach
    public void setUp() {
        outputStream = new ByteArrayOutputStream();
    }

    @Test
    public void testStreamFilesToZip_WithValidPairs() throws IOException {
        // Mock S3 response for listObjectsV2
        ListObjectsV2Response listResponse = ListObjectsV2Response.builder()
                .contents(
                        S3Object.builder().key("folder/file1.json").build(),
                        S3Object.builder().key("folder/file1.xml").build(),
                        S3Object.builder().key("folder/file2.json").build(),
                        S3Object.builder().key("folder/file2.xml").build()
                )
                .build();
        when(s3AsyncClient.listObjectsV2(any(ListObjectsV2Request.class)))
                .thenReturn(CompletableFuture.completedFuture(listResponse));

        // Mock S3 response for getObject
        when(s3AsyncClient.getObject(any(), any(AsyncResponseTransformer.class)))
                .thenReturn(CompletableFuture.completedFuture(SdkBytes.fromUtf8String("file content")));

        // Call the method under test
        s3Service.streamFilesToZip("test-bucket", "folder/", 0, 2, outputStream);

        // Verify the output
        byte[] zipBytes = outputStream.toByteArray();
        assertTrue(zipBytes.length > 0, "Zip file should not be empty");

        // Verify interactions
        verify(s3AsyncClient, times(1)).listObjectsV2(any(ListObjectsV2Request.class));
        verify(s3AsyncClient, times(4)).getObject(any(), any(AsyncResponseTransformer.class));
    }

    @Test
    public void testStreamFilesToZip_WithMissingPairs() throws IOException {
        // Mock S3 response for listObjectsV2
        ListObjectsV2Response listResponse = ListObjectsV2Response.builder()
                .contents(
                        S3Object.builder().key("folder/file1.json").build(),
                        S3Object.builder().key("folder/file2.xml").build()
                )
                .build();
        when(s3AsyncClient.listObjectsV2(any(ListObjectsV2Request.class)))
                .thenReturn(CompletableFuture.completedFuture(listResponse));

        // Call the method under test
        s3Service.streamFilesToZip("test-bucket", "folder/", 0, 2, outputStream);

        // Verify the output
        byte[] zipBytes = outputStream.toByteArray();
        assertEquals(0, zipBytes.length, "Zip file should be empty (no valid pairs)");

        // Verify interactions
        verify(s3AsyncClient, times(1)).listObjectsV2(any(ListObjectsV2Request.class));
        verify(s3AsyncClient, never()).getObject(any(), any(AsyncResponseTransformer.class));
    }

    @Test
    public void testStreamFilesToZip_WithStartIndex() throws IOException {
        // Mock S3 response for listObjectsV2
        ListObjectsV2Response listResponse = ListObjectsV2Response.builder()
                .contents(
                        S3Object.builder().key("folder/file1.json").build(),
                        S3Object.builder().key("folder/file1.xml").build(),
                        S3Object.builder().key("folder/file2.json").build(),
                        S3Object.builder().key("folder/file2.xml").build()
                )
                .build();
        when(s3AsyncClient.listObjectsV2(any(ListObjectsV2Request.class)))
                .thenReturn(CompletableFuture.completedFuture(listResponse));

        // Mock S3 response for getObject
        when(s3AsyncClient.getObject(any(), any(AsyncResponseTransformer.class)))
                .thenReturn(CompletableFuture.completedFuture(SdkBytes.fromUtf8String("file content")));

        // Call the method under test with startIndex = 1
        s3Service.streamFilesToZip("test-bucket", "folder/", 1, 1, outputStream);

        // Verify the output
        byte[] zipBytes = outputStream.toByteArray();
        assertTrue(zipBytes.length > 0, "Zip file should not be empty");

        // Verify interactions
        verify(s3AsyncClient, times(1)).listObjectsV2(any(ListObjectsV2Request.class));
        verify(s3AsyncClient, times(2)).getObject(any(), any(AsyncResponseTransformer.class));
    }

    @Test
    public void testStreamFilesToZip_WithInvalidBucket() {
        // Mock S3 response for listObjectsV2 to simulate an error
        when(s3AsyncClient.listObjectsV2(any(ListObjectsV2Request.class)))
                .thenReturn(CompletableFuture.failedFuture(new RuntimeException("Bucket not found")));

        // Call the method under test and expect an exception
        assertThrows(RuntimeException.class, () -> {
            s3Service.streamFilesToZip("invalid-bucket", "folder/", 0, 2, outputStream);
        });

        // Verify interactions
        verify(s3AsyncClient, times(1)).listObjectsV2(any(ListObjectsV2Request.class));
    }
}





















import software.amazon.awssdk.core.async.AsyncResponseTransformer;
import software.amazon.awssdk.services.s3.S3AsyncClient;
import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;
import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;
import software.amazon.awssdk.services.s3.model.S3Object;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@Service
public class S3Service {

    private final S3AsyncClient s3AsyncClient;

    public S3Service() {
        // Initialize the S3 Async Client
        this.s3AsyncClient = S3AsyncClient.create();
    }

    public void streamFilesToZip(String bucketName, String prefix, int startIndex, int count, OutputStream outputStream) throws IOException {
        String continuationToken = null; // Pagination token
        int downloadedCount = 0;
        int currentIndex = 0;

        // Map to track file pairs (base name -> {json, xml})
        Map<String, FilePair> filePairs = new HashMap<>();

        try (ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream)) {
            do {
                // Create a request with the pagination token
                ListObjectsV2Request request = ListObjectsV2Request.builder()
                        .bucket(bucketName)
                        .prefix(prefix)
                        .continuationToken(continuationToken)
                        .build();

                // List objects in the bucket asynchronously
                CompletableFuture<ListObjectsV2Response> listObjectsFuture = s3AsyncClient.listObjectsV2(request);
                ListObjectsV2Response result = listObjectsFuture.join(); // Block until the response is received

                List<S3Object> objects = result.contents();
                for (S3Object object : objects) {
                    String key = object.key();
                    String baseName = getBaseName(key);

                    // Track .json and .xml files
                    if (key.endsWith(".json")) {
                        filePairs.computeIfAbsent(baseName, k -> new FilePair()).setJsonKey(key);
                    } else if (key.endsWith(".xml")) {
                        filePairs.computeIfAbsent(baseName, k -> new FilePair()).setXmlKey(key);
                    }
                }

                // Get the next token for pagination
                continuationToken = result.nextContinuationToken();
            } while (continuationToken != null);

            // Process file pairs
            for (Map.Entry<String, FilePair> entry : filePairs.entrySet()) {
                FilePair pair = entry.getValue();

                // Skip files without a corresponding pair
                if (pair.getJsonKey() == null || pair.getXmlKey() == null) {
                    continue;
                }

                // Skip files until the startIndex is reached
                if (currentIndex < startIndex) {
                    currentIndex++;
                    continue;
                }

                // Stop after downloading the required number of files
                if (downloadedCount >= count * 2) break;

                // Download and add .json file to the zip
                downloadAndAddToZip(bucketName, pair.getJsonKey(), zipOutputStream);
                downloadedCount++;

                // Download and add .xml file to the zip
                downloadAndAddToZip(bucketName, pair.getXmlKey(), zipOutputStream);
                downloadedCount++;
            }
        }
    }

    private void downloadAndAddToZip(String bucketName, String key, ZipOutputStream zipOutputStream) {
        CompletableFuture<Void> downloadFuture = s3AsyncClient.getObject(
                builder -> builder.bucket(bucketName).key(key),
                AsyncResponseTransformer.toBytes()
        ).thenAccept(responseBytes -> {
            try {
                // Add a new entry to the zip file
                ZipEntry zipEntry = new ZipEntry(key.substring(key.lastIndexOf("/") + 1));
                zipOutputStream.putNextEntry(zipEntry);

                // Write the file content to the zip
                zipOutputStream.write(responseBytes.asByteArray());

                zipOutputStream.closeEntry();
            } catch (IOException e) {
                throw new RuntimeException("Failed to write file to zip", e);
            }
        });

        downloadFuture.join(); // Block until the file is downloaded and written to the zip
    }

    private String getBaseName(String key) {
        // Remove the file extension and path to get the base name
        String fileName = key.substring(key.lastIndexOf("/") + 1);
        return fileName.replace(".json", "").replace(".xml", "");
    }

    // Helper class to track .json and .xml file pairs
    private static class FilePair {
        private String jsonKey;
        private String xmlKey;

        public String getJsonKey() {
            return jsonKey;
        }

        public void setJsonKey(String jsonKey) {
            this.jsonKey = jsonKey;
        }

        public String getXmlKey() {
            return xmlKey;
        }

        public void setXmlKey(String xmlKey) {
            this.xmlKey = xmlKey;
        }
    }
}
----------------------

service 
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.amazonaws.services.s3.model.ListObjectsV2Request;
import com.amazonaws.services.s3.model.ListObjectsV2Result;
import com.amazonaws.services.s3.model.S3Object;
import com.amazonaws.services.s3.model.S3ObjectSummary;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

@Service
public class S3Service {

    private final AmazonS3 s3Client;

    public S3Service() {
        // Initialize the S3 client
        this.s3Client = AmazonS3ClientBuilder.standard().build();
    }

    public void streamFilesToZip(String bucketName, String prefix, int startIndex, int count, OutputStream outputStream) throws IOException {
        // Check if the bucket exists
        if (!s3Client.doesBucketExistV2(bucketName)) {
            throw new IllegalArgumentException("Bucket does not exist: " + bucketName);
        }

        String nextToken = null; // Pagination token
        int downloadedCount = 0;
        int currentIndex = 0;

        try (ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream)) {
            do {
                // Create a request with the pagination token
                ListObjectsV2Request request = new ListObjectsV2Request()
                        .withBucketName(bucketName)
                        .withPrefix(prefix)
                        .withContinuationToken(nextToken);

                // List objects in the bucket
                ListObjectsV2Result result = s3Client.listObjectsV2(request);

                for (S3ObjectSummary objectSummary : result.getObjectSummaries()) {
                    String key = objectSummary.getKey();
                    if (key.endsWith(".json") || key.endsWith(".xml")) {
                        // Skip files until the startIndex is reached
                        if (currentIndex < startIndex) {
                            currentIndex++;
                            continue;
                        }

                        // Stop after downloading the required number of files
                        if (downloadedCount >= count * 2) break;

                        // Stream the file from S3 directly into the zip
                        S3Object s3Object = s3Client.getObject(bucketName, key);
                        try (InputStream inputStream = s3Object.getObjectContent()) {
                            // Add a new entry to the zip file
                            ZipEntry zipEntry = new ZipEntry(key.substring(key.lastIndexOf("/") + 1));
                            zipOutputStream.putNextEntry(zipEntry);

                            // Write the file content to the zip
                            byte[] buffer = new byte[8192]; // 8 KB buffer
                            int bytesRead;
                            while ((bytesRead = inputStream.read(buffer)) != -1) {
                                zipOutputStream.write(buffer, 0, bytesRead);
                            }

                            zipOutputStream.closeEntry();
                            downloadedCount++;
                        }
                    }
                }

                // Get the next token for pagination
                nextToken = result.getNextContinuationToken();
            } while (nextToken != null && downloadedCount < count * 2); // Continue until all files are processed or the required count is reached
        }
    }
}






--------------------------------------\



import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            errors.put(error.getField(), error.getDefaultMessage());
        });
        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.BAD_REQUEST);
    }
}

------------------------------------------

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletResponse;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;
import java.io.IOException;
import java.io.OutputStream;

@RestController
@Validated // Enable validation for this controller
public class S3Controller {

    @Autowired
    private S3Service s3Service;

    @GetMapping("/download-and-zip")
    public void downloadAndZipFiles(
            @RequestParam @NotEmpty(message = "Bucket name cannot be empty") String bucketName,
            @RequestParam @NotEmpty(message = "Prefix cannot be empty") String prefix,
            @RequestParam @NotNull(message = "Start index cannot be null") @Min(value = 0, message = "Start index must be greater than or equal to 0") int startIndex,
            @RequestParam @NotNull(message = "Count cannot be null") @Min(value = 1, message = "Count must be greater than or equal to 1") int count,
            HttpServletResponse response) throws IOException {

        // Set response headers
        response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);
        response.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=files.zip");

        // Stream files directly to the response output stream
        try (OutputStream outputStream = response.getOutputStream()) {
            s3Service.streamFilesToZip(bucketName, prefix, startIndex, count, outputStream);
        }
    }
}
